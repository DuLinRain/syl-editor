# 编辑区(一)

## 一、实验介绍

### 1.1 实验内容

在本节实验中，我们将要开发编辑器最大的组件：编辑区。也是编辑器最重要的组件。所有的操作都在这里展示效果。所以这部分的内容较多，将分为两个实验进行讲解。

### 1.2 实验知识点

* 文本编辑区功能实现
* Selection/Range
* vuex


### 1.3 实验环境【实验使用的实验环境及核心开发及部署软件简单介绍】
+ python2.7   
+ Xfce终端
+ 新版 firefox 浏览器

## 二、编码实现

在前面的实验中，我们介绍了编辑器的各个组件的整合，其中也提到了编辑区。不过到了本节实验，需要对代码进行一些修改。

模板部分：

```Html
<template>
  <div class="syl-editor-editarea">
    <div class="edit-area" id="syl-editor-body" contenteditable="true">
    </div>
  </div>
</template>
```

模板内容暂时不变。

script 部分，这里我一步一步讲解再贴上代码。

首先，从 `vuex` 中导入一个叫做 `mapState` 的函数模块。这个函数是一个辅助函数，当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 `mapState` 辅助函数帮助我们生成计算属性，可以精简代码。

```js
import { mapState } from 'vuex'
```

* data()

  ```js
   data() {
        return {
          editorBody: '',
          currentRange: null,
          rangeFocus: false,
          isInit: false,
        }
      },
  ```

  这里有四个数据，第一个表示编辑区，即模板中的 `syl-editor-body` ，暂时为空。第二个表示当前的 range 对象，一般来说，页面上只会存在一个 range 对象(firefox单独考虑 )。当操作菜单栏的功能时，大部分都是作用于当前的 range 对象。所以需要将它保存。第三个数据表示当前 range 的 focus 状态。即如果焦点不在编辑区内部，此时再来操作菜单，菜单的功能可能会执行失败。所以这是需要注意的地方。第四个表示是否已经初始化编辑区，它的值将会影响一些操作。

* computed

  ```js
  computed: mapState({
        menus: 'menuBar',
        content: 'content',
        command: 'command'
      }),
  ```

  因为使用了 mapState 辅助函数，所以计算属性的代码更加简洁。如果不适用辅助函数，则代码应该修改为：

  ```js
  computed: {
    menus: function() {
      return this.$store.state.menus
    },
    content: function() {
      ......
    }
    ........
  }
  ```

  上面代码中，主要获取了三个状态数据：菜单栏 `menus`，编辑区展示的内容 `contents`，以及执行命令 `command` 。

  到目前为止，我们的菜单功能基本完成了，但是却一直没有使用。每一个菜单项，最终的操作都只是分发相关的 action ，并没有做其他的事情，据我们所知，分发的 action 也只是提交相应的 mutation，mutation 的作用也仅仅是保存相关的状态和数据，并没有做具体的实现功能。那么，菜单所分发的 action 如何才能反映到编辑区内呢？

  实现的方法当然是数据监听，通过监听 state 中的 command 的值的变化，然后具体执行菜单的功能。此外，我们还需要监听 state 中的 content 数据值，以便于及时更新编辑区的内容展示。所以，代码如下：

  ```js
      watch: {
        'content': function(val) {
          //如果内容有变动，则更新编辑区内的内容
          if(this.editorBody.innerHTML != val) {
            this.editorBody.innerHTML = val
            this.updateMenuState()
          }
        },
        'command': function(cmd) {
          //如果command 有变动，则调用 exec 方法执行命令
          this.exec(cmd.name, cmd.value)
        }
      },
  ```

* methods

  所有的方法都集中在这个属性里。

  首先，我们需要进行初始化操作，这里的初始化主要有4个步骤：

  ```JS
  init() {
    //编辑区元素节点
    this.editorBody = document.getElementById('syl-editor-body')
    //初始化编辑区内容
    this.initEditBody()		
    //添加事件监听事件
    this.addListener()
    //编辑区聚焦
    this.editareaFocus()
  },
  ```

  接下里的介绍一下上面的三个方法。

* 初始化编辑区内容

  通常，当编辑区的内容为空的情况下，会触发编辑区内容的初始化，即展示预设的文本内容。可能你已经想到了，在配置文件中，我们对编辑区做了一些参数设置，其中就包括了 content 的值的设置。因为 content 的值是可变的，所以需要

## 三、实验总结

